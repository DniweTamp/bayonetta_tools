struct {
    uint offsetEvents<format=hex>;
    uint eventCount;
    uint offsetCharSet<format=hex>;
    uint charCount;
    uint offsetCharGraphs<format=hex>;
    uint charGraphsCount;
    uint offsetSpecialGraphs<format=hex>;
    uint specialGraphsCount;
    uint offsetUsedEvents<format=hex>;
    uint usedEventCount;
} header;

typedef struct {
    ushort code;
    short positionOffset;
}letter<read=letter_Read>;

typedef short lang<comment="0x1: subtitle, 0x2: Japanese alphabet, 0x4: Latin alphabet, 0x10: unknown (always on)">;

FSeek(header.offsetCharSet);
struct {
    lang languageFlags;
    wchar_t c;
    uint index;
} chars[header.charCount];

wstring letter_Read(letter &let) {
    wstring s = L"";
    if(let.code <= 0x8000) {
        s += chars[let.code].c;
    } else if (let.code == 0x8003) {
        s += L"<LeftStick>";
    } else {
        s += L' ';
    }
    return s;
}

FSeek(header.offsetEvents);
local uint pos;
local uint pos2;
local uint pos3;
struct {
    uint paragraphsOffset<format=hex>;
    uint paragraphCount;
    uint sequenceNumber<comment="Unknown usage">;
    uint eventID<format=hex>;
    pos = FTell();
    FSeek(paragraphsOffset);
    struct {
        uint stringsOffset<format=hex>;
        int stringCount;
        float belowSpacing;
        float horizontalSpacing;
        lang languageFlags;
        short padding<hidden=true>;
        pos2 = FTell();
        FSeek(stringsOffset);
        struct strng{
            uint stringOffset<format=hex>;
            uint u_a<comment="always found 0">;
            uint length;
            uint length2<comment="always same as length">;
            float belowSpacing;
            float horizontalSpacing;
            pos3 = FTell();
            FSeek(stringOffset);
            if ((length-1)/2>0) {
                letter letters[(length-1)/2];
            }
            ushort terminator;
            FSeek(pos3);
        }strs[stringCount]<optimize=false,read=read_strng>;
        FSeek(pos2);
    } paragraph[paragraphCount]<optimize=false>;
    FSeek(pos);
} events[header.eventCount]<optimize=false>;

wstring read_strng(strng &str) {
    wstring s = L"";
    int i = 0;
    for(i = 0; i < (str.length - 1)/2; i++) {
        if(str.letters[i].code == 0x8001) {
            s += L' ';
        } else if (str.letters[i].code == 0x8003) {
            s += L"<LeftStick>";
        } else {
            s += chars[str.letters[i].code].c;
        }
    }
    return s;
}

FSeek(header.offsetCharGraphs);
struct {
    uint textureID<format=hex>;
    float u1;
    float v1;
    float u2;
    float v2;
    float width;
    float height;
    float u_a;
    float belowSpacing;
    float horizontalSpacing;
} charGraphs[header.charGraphsCount];

FSeek(header.offsetSpecialGraphs);
struct {
    uint languageFlags;
    float width;
    float height;
    float belowSpacing;
    float horizontalSpacing;
} specialGraphs[header.specialGraphsCount];

FSeek(header.offsetUsedEvents);
struct {
    uint eventID<format=hex>;
    uint enventIndex;
    char name[32];
} usedEvents[header.usedEventCount]<comment="Ordered by eventID">;
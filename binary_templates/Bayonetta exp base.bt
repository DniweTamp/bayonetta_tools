struct {
    char    id[4];
    int32   u_a;
    int32   offsetRecord;
    int32   numRecord;

} header;

FSeek(header.offsetRecord);

struct {
    int16   u_e;
    int16   bone_index;
    char    animation_track;
    char    entry_type;
    char    u_h;
    char    u_i;
    int32   u_j;
    uint32  offset <format=hex>;
    int32   u_d;
} record[header.numRecord];

local int i;
for( i = 0; i < header.numRecord; i++) {
    FSeek(record[i].offset);
    
    switch (record[i].entry_type) {
    case 0:
        break;
    case 1: // Copy
        struct {
            uint32  flag <format=hex>;
            int16   bone_index;
            char    animation_track;
            char    padding;
        } entry<bgcolor=cRed>;
        break;
    case 2: // Scal
        struct {
            uint32  flag <format=hex>;
            int16   bone_index;
            char    animation_track;
            char    padding;
            struct {
                uint32  flag <format=hex, comment="0x4: mul, 0x1: add">;
                float   val;
            } coeff;
        } entry<bgcolor=cGreen>;
        break;
    case 3: // Usually mul then add
        struct {
            uint32  flag <format=hex>;
            int16   bone_index;
            char    animation_track;
            char    padding;
            struct {
                uint32  flag <format=hex, comment="0x4: mul, 0x1: add">;
                float   val;
            } coeffs[2];
        } entry<bgcolor=cBlue>;
        break;
    }
}
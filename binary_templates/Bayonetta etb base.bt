typedef struct {
    float x;
    float y;
    float z;
} vector_t<read=vectorRead>;


string vectorRead( vector_t &value ) {
    string s;
    SPrintf(s, "x: %f, y: %f, z: %f", value.x, value.y, value.z);
    return s;
}

typedef struct {
    float x;
    float y;
    float z;
    float w;
} vector4_t<read=vector4Read>;

typedef struct {
    vector4_t r0;
    vector4_t r1;
    vector4_t r2;
    vector4_t r3;
} matrix_t;

string vector4Read( vector4_t &value ) {
    string s;
    SPrintf(s, "x: %f, y: %f, z: %f, w: %f", value.x, value.y, value.z, value.w);
    return s;
}

string objectTypes(uint t) {
    switch(t) {
    case 0:
        return "sc";
    case 1:
        return "pl";
    case 2:
        return "em";
    case 3:
        return "wp";
    case 4:
        return "bg";
    case 5:
        return "gm";
    case 6:
        return "et";
    case 7:
        return "ef";
    case 6:
        return "rp";
    case 9:
        return "it";
    case 10:
        return "id";
    case 11:
        return "es";
    case 12:
        return "bm";
    case 13:
        return "ic";
    case 14:
    case 15:
        return "??";
    case 16:
        return "ct";
    default:
        return "??";
    }
}

string objectIDRead(uint objectID) {
    string s;
    SPrintf(s, "%s%04x", objectTypes(objectID >> 16), objectID & 0xffff);
    return s;
}

struct {
    char     id[4];
    float    version;
    byte     num_verse;
    byte     u_a[3];
    uint     u_b;
} header;

typedef struct {
    uint     objectID <format=hex, read=objectIDRead>;
    short    flags;
    byte     u_b;
    byte     count<comment="summed by engine (maybe a count: 3 for dears em0010)">;
    byte     u_d[4]<comment="first 2 bytes set by engine to u_c and 0">;
    short    u_e;
    short    u_f;
    vector_t position;
    byte     u_g[4];
    byte     u_h[64];
} ennemy_t;

local uint pos;
struct {
    short    u_a1<comment="Special treatment for level 120 when 4 or 20 (swapped) and 210 when 10 or 40 (swapped)">;
    short    u_a2<comment="Special treatment for level 120 when 4 or 20 (swapped) and 210 when 10 or 40 (swapped)">;
    uint     flags;
    uint     offset_a<format=hex>;
    uint     offset_b<format=hex>;
    uint     offset_c<format=hex>;
    vector_t position;
    byte     u_c0;
    byte     default_comp;
    byte     u_c2;
    byte     u_c3;
    byte     normal_ennemy_count<comment="Hard limit 32 ennemies">;
    byte     easy_ennemy_count<comment="Hard limit 32 ennemies">;
    byte     hard_ennemy_count<comment="Hard limit 32 ennemies">;
    byte     very_easy_ennemy_count<comment="Hard limit 32 ennemies">;
    byte     nsic_ennemy_count<comment="Hard limit 32 ennemies">;
    byte     u_d[3];
    uint     offset_ennemies_normal<format=hex>;
    uint     offset_ennemies_easy<format=hex>;
    uint     offset_ennemies_hard<format=hex>;
    uint     offset_ennemies_very_easy<format=hex>;
    uint     offset_ennemies_nsic<format=hex>;
    matrix_t transform;
    uint     offset_e<format=hex, comment="used when version == 3.2, else offset_a">;
    int      usedByEngine<comment="set to -1 if version < 4.3">;
    int      u_d;
    byte     normal_comp<comment="if 0default to default, wave size?">;
    byte     easy_comp<comment="if 0 default to normal, wave size?">;
    byte     hard_comp<comment="if 0 default to normal, wave size?">;
    byte     very_easy_comp<comment="if 0 default to easy, wave size?">;
    byte     nsic_comp<comment="if 0 default to hard, wave size?">;
    byte     padding[3];
    uint     u_e[7];

    pos = FTell();
    FSeek(offset_ennemies_normal);
    ennemy_t ennemies_normal[normal_ennemy_count];
    FSeek(offset_ennemies_easy);
    ennemy_t ennemies_easy[easy_ennemy_count];
    FSeek(offset_ennemies_hard);
    ennemy_t ennemies_hard[hard_ennemy_count];
    FSeek(offset_ennemies_very_easy);
    ennemy_t ennemies_very_easy[very_easy_ennemy_count];
    FSeek(offset_ennemies_nsic);
    ennemy_t ennemies_nsic[nsic_ennemy_count];
    FSeek(pos);
} verses[header.num_verse]<optimize=false>;


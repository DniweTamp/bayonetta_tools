#define BAYONETTA  0
#define BAYONETTA2 1

struct {
	char    id[4]; //WMB
    int32   unknownA;
    int32   unknownB;
    int32   numVertexes;
    char    vertexExDataSize;
    char    vertexExData;
    int16   unknownE;
    int32   unknownF;
    uint32  offsetVertexes;
    uint32  offsetVertexesExData;
    int32   unknownG[4];
    int32   numBones;
    uint32  offsetBoneHierarchy;
    uint32  offsetBoneRelativePosition;
    uint32  offsetBonePosition;
    uint32  offsetBoneIndexTranslateTable;
    int32   numMaterials;
    uint32  offsetMaterialsOffsets;
    uint32  offsetMaterials;
    int32   numMeshes;
    uint32  offsetMeshesOffsets;
    uint32  offsetMeshes;
    int32   unknownK;
    int32   unknownL;
    uint32  offsetUnknownJ;
    uint32  offsetBoneSymmetries;
    uint32  offsetBoneFlags;
    int32   exMatInfo[4];
} header;

FSeek( header.offsetVertexes );

typedef struct {
    hfloat u;
    hfloat v;
} mapping_t<read=mapping_tRead>;

string mapping_tRead( mapping_t &value ) {
    string s;
    SPrintf(s, "u: %f, v: %f", value.u, value.v);
    return s;
}

typedef struct {
        float  x;
        float  y;
        float  z;
} vector<read=vectorRead>;

string vectorRead( vector &value ) {
    string s;
    SPrintf(s, "x: %f, y: %f, z: %f", value.x, value.y, value.z);
    return s;
}

typedef ubyteList color_t;
typedef ubyteList boneIndexes_t;
typedef ubyteList boneWeights_t;

float tangentRead( uchar value) {
    float v;
    v = value;
    v -= 127.0;
    v /= 127.0;
    return v;
}

if (( header.unknownB & 0xff ) > 0xf ) {
    struct {
        vector          position;
        mapping_t       mapping;
        normals_t       normals;
        tangents_t      tangents;
        boneIndexes_t   boneIndexes;
        boneWeights_t   boneWeights;
    } vertexes[header.numVertexes];
} else if ( ( header.unknownB & 0xff ) == 0xf ) {
    if ( header.vertexExDataSize == 1 ) {
        struct {
            vector      position;
            mapping_t   mapping;
            normals_t   normals;
            ubyteList   unknwonA;
            ubyteList   unknownB;
        } vertexes[header.numVertexes];
    } else {
        struct {
            vector      position;
            mapping_t   mapping;
            normals_t   normals;
            ubyteList   unknwonA;
            ubyteList   unknownB;
            mapping_t   mapping2;
        } vertexes[header.numVertexes];
    }
} else if ( ( header.unknownB & 0xff ) == 0xd ) {
    struct {
        vector      position;
        mapping_t   mapping;
        normals_t   normals;
        ubyteList   unknwonA;
    } vertexes[header.numVertexes];
}

if ( header.offsetVertexesExData ) {
FSeek( header.offsetVertexesExData );
if ( header.vertexExDataSize == 2 ) {
    struct {
        color_t     color;
        mapping_t   mapping;
    } vertexesExData[header.numVertexes];
} else {
    struct {
        color_t     color;
    } vertexesExData[header.numVertexes];
}
}

if ( header.offsetBoneHierarchy ) {
FSeek( header.offsetBoneHierarchy);
int16 boneParents[header.numBones];
}

if ( header.offsetBoneRelativePosition) {
FSeek( header.offsetBoneRelativePosition);
vector boneRelativePositions[header.numBones];
}

if ( header.offsetBonePosition) {
FSeek( header.offsetBonePosition);
vector bonePositions[header.numBones];
}

if ( header.offsetBoneIndexTranslateTable) {
FSeek( header.offsetBoneIndexTranslateTable );
struct {
    int16 firstLevel[16];
    local int i;
    local int j = 0;
    for (i = 0; i < 16; i++) {
        if ( firstLevel[i] != -1 ) { 
            j += 1;
         }
    } 
    int16 secondLevel[j*16];
    local int k = 0;
    for (i = 0; i < j*16; i++) {
        if ( secondLevel[i] != -1 ) {
            k += 1;
        }
    }
    int16 thirdLevel[k*16];
} BoneIndexTranslateTable;
}

if ( header.offsetUnknownJ ) {
    FSeek( header.offsetUnknownJ );
    struct {
        struct {
            byte    unknownA[4];
            int32   unknownB;
            int16   unknownC[4];
        } unknownInnerStruct[2];
        byte    unknownA[4];
        int32   unknownB;
    } unknownStruct;
}

if ( header.offsetBoneSymmetries ) {
    FSeek( header.offsetBoneSymmetries );
    int16 boneSymmetries[header.numBones];
}

if ( header.offsetBoneFlags ) {
    FSeek( header.offsetBoneFlags );
    byte boneFlags[header.numBones];
}


if ( header.exMatInfo[0] ) {
    FSeek( header.exMatInfo[0] );
    struct {
        char shaderName[16];
    } shaderNames[header.numMaterials];
}

if ( header.exMatInfo[1] ) {
    FSeek( header.exMatInfo[1] );
    int32 numTexIDs;
    struct { 
        uint32  TexID;
        int32   type;
    } texIDs[numTexIDs];
}

FSeek( header.offsetMaterialsOffsets );
uint32 materialOffsets[header.numMaterials];

local int i;
local int dataSize;
for ( i = 0; i < header.numMaterials - 1; i++ ) {
    FSeek( header.offsetMaterials + materialOffsets[i] );
    struct {
        int16 matID <format=hex>;
        int16 matFlags <format=hex>;
        union {
            uint32  texture <format=hex>;
            float   val;
        } texture[5];
        dataSize = materialOffsets[i+1] - materialOffsets[i] - 24;
        if (dataSize > 0) {
            float   data[dataSize/4];
        }
    } material;
}
FSeek( header.offsetMaterials + materialOffsets[header.numMaterials - 1] );
struct {
    int16 matID <format=hex>;
    int16 matFlags <format=hex>;
    union {
        uint32  texture <format=hex>;
        float   val;
    } texture[5];
    dataSize = header.offsetMeshesOffsets - (header.offsetMaterials + materialOffsets[header.numMaterials - 1]) - 24;
    float   data[dataSize/4];
} material;

FSeek( header.offsetMeshesOffsets );
uint32 meshesOffsets[header.numMeshes];

local int j;
typedef struct {
    struct {
        int16   batchIdx <comment="Bayonetta 2">;
        int16   id;
        uint16   unknownB <format=hex>;
        int16   exMaterialID;
        byte    materialID;
        byte    unknownD;
        byte    unknownE1;
        byte    unknownE2;
        int32   vertexStart;
        int32   vertexEnd;
        int32   primitiveType <comment="4: triangles, 5: triangles strip">;
        uint32  offsetIndices;
        int32   numIndices;
        int32  vertexOffset;
        int32   unknownF[7];
    } batchHeader;
    if ((batchHeader.unknownB & 0x8000) || (batchHeader.unknownB & 0x80)) {
        int32 numBoneRefs;
        if(numBoneRefs > 0) {
            uchar boneRefs[numBoneRefs];
        }
    } else {
        struct {
            float unknown[4];
        } unknown;
    }
    FSeek( header.offsetMeshes + meshesOffsets[i] + meshHeader.offsetBatchOffsets + batchOffsets[j] + batchHeader.offsetIndices);
    uint16 indices[batchHeader.numIndices];
} batch;

typedef    struct {
    struct {
        int16   id;
        int16   numBatch;
        int16   unknownA1;
        int16   unknownA2;
        uint32  offsetBatchOffsets;
        int32   unknownB <format=hex>;
        int32   unknownC[4];
        char    name[32];
        float   mat[12];
    } meshHeader;
    FSeek( header.offsetMeshes + meshesOffsets[i] + meshHeader.offsetBatchOffsets );
    uint32 batchOffsets[meshHeader.numBatch];
    for( j = 0; j < meshHeader.numBatch; j++) {
        FSeek( header.offsetMeshes + meshesOffsets[i] + meshHeader.offsetBatchOffsets + batchOffsets[j] );
        batch batches;
    }
} mesh <read=meshRead>;

string meshRead( mesh &value ) {
    return value.meshHeader.name;
}

for( i=0; i<header.numMeshes; i++) {
    FSeek( header.offsetMeshes + meshesOffsets[i] );
    mesh meshes;
}
